> 1. 哪些寄存器保存函数的参数？例如，在`main`对`printf`的调用中，哪个寄存器保存13？

函数参数主要使用 `a0` 到 `a7`寄存器保存。

2. `main`的汇编代码中对函数`f`的调用在哪里？对`g`的调用在哪里(提示：编译器可能会将函数内联）

`g` 函数只是简单地返回参数加 3。在 `f` 函数和 `main` 函数中出现了 `addiw a0, a0, 3` 指令，这是 `g` 函数内联后的代码。`f` 函数返回 `g(x)`。可以看到在 `f` 函数和 `main` 函数中，都包含了 `addiw a0, a0, 3` 指令。这意味着 `f` 函数调用 `g` 也被内联了。

从以上的 `main` 函数代码片段中，我们看不到显式的 `call` 指令来调用 `f` 或 `g`。但是，从 `main` 函数中可以看到，使用`li a1, 12` (加载 12 到 `a1`)，而不是调用 `f(8)+1` 这种函数调用。这说明`main` 函数中对 `f` 和 `g` 函数的调用，被编译器内联了，即编译器将函数的代码直接插入调用点，而不是生成函数调用指令。

> 3. `printf`函数位于哪个地址

由代码可知地址为630.

> 4. 在`main`中`printf`的`jalr`之后的寄存器`ra`中有什么值？

在 `main` 中使用 `auipc ra,0x0` 将当前程序计数器 `pc` 的值存入 `ra` 中，再调用 `printf` 的 `jalr` 指令之后，寄存器 `ra` 中会保存返回地址，也就是 `printf` 函数返回时要跳转回的地址。我们可以通过查看 `jalr` 指令之后的指令地址来确定这个返回地址。

```
30:	00000097          	auipc	ra,0x0
34: 600080e7           jalr 1536(ra) # 630 <printf>
```

`jalr` 指令的执行会将下一个指令的地址（即 `jalr` 指令的地址加上 4 个字节）保存到 `ra` 中。因此，`jalr` 指令之后的指令地址是 `0x34 + 4 = 0x38`，即 `exit(0)` 的指令地址。

> 5. 运行以下代码，程序的输出是什么？

> ```c
> unsigned int i = 0x00646c72;
> printf("H%x Wo%s", 57616, &i);
> ```

在Makefile中添加$/_call\,并把user/call.c main中代码改成上述代码。运行qemu后输入call，得到结果：

在小端存储中（低位存在低地址处），i内存布局如下（按字节存储）：

```
0x00:   0x72
0x01:   0x6c
0x02:   0x64
0x03:   0x00
```

- `%x`：将 `57616` 以十六进制格式输出为 `e110`。
- `%s`：从 `&i` 的地址开始，读取到字符串结束符 `\0`。即读取的字符串为 `rld`。

如果是大端存储架构，i的存储顺序为：

```
0x00:   0x00
0x01:   0x64
0x02:   0x6c
0x03:   0x72
```

为了得到相同的输出 `"He110 World"`，我们需要将字节顺序重新排列为小端存储所期望的顺序。这意味着我们需要设置 `i` 为 `0x726c6400`，得出的结果相同。

> 6. 在下面的代码中，“`y=`”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？

```c
printf("x=%d y=%d", 3);
```

打印结果中，“y=”之后将打印一个未定义的值或者是一个随机的值。这种情况发生的原因是 `printf` 函数的格式字符串指定了两个 `%d`，但只提供了一个整数参数 `3`。在 `printf` 函数执行时，它会按照格式字符串中的指定顺序去访问对应的参数，然而实际参数数量和格式字符串中指定的数量不匹配。